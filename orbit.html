<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>嫦娥六号飞行轨迹3D模型</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000;
            color: white;
            font-family: Arial, sans-serif;
        }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            z-index: 100;
        }
        #container {
            width: 100%;
            height: 100vh;
        }
    </style>
</head>
<body>
    <div id="container"></div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script>
        // 初始化场景、相机和渲染器
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(22, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000000);
        document.getElementById('container').appendChild(renderer.domElement);

        // 设置相机位置
        camera.position.set(0, 180, 0);
        camera.lookAt(0, 0, 0);

        // 添加环境光和定向光
        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(1, 1, 1);
        scene.add(directionalLight);

        // 创建地球
        const earthGeometry = new THREE.SphereGeometry(8, 64, 64);
        const earthMaterial = new THREE.MeshPhongMaterial({
            map: new THREE.TextureLoader().load('https://threejs.org/examples/textures/planets/earth_atmos_2048.jpg'),
            bumpMap: new THREE.TextureLoader().load('https://threejs.org/examples/textures/planets/earth_normal_2048.jpg'),
            bumpScale: 0.05,
            specularMap: new THREE.TextureLoader().load('https://threejs.org/examples/textures/planets/earth_specular_2048.jpg'),
            specular: new THREE.Color('grey')
        });
        const earth = new THREE.Mesh(earthGeometry, earthMaterial);
        earth.position.set(-50, 0, 0);
        scene.add(earth);

        // 添加地球近地轨道（白色虚线圆环）
        const orbitRadius = 10;
        const orbitGeometry = new THREE.BufferGeometry().setFromPoints(
            new THREE.EllipseCurve(0, 0, orbitRadius, orbitRadius, 0, Math.PI * 2, false, 0)
                .getPoints(100)
        );
        const orbitMaterial = new THREE.LineDashedMaterial({
            color: 0xffffff,
            dashSize: 0.5,
            gapSize: 0.3,
            linewidth: 1
        });
        const orbit = new THREE.Line(orbitGeometry, orbitMaterial);
        orbit.position.copy(earth.position);
        orbit.rotation.x = Math.PI / 2;
        orbit.computeLineDistances();
        scene.add(orbit);

        // 创建月球
        const moonGeometry = new THREE.SphereGeometry(2.5, 64, 64);
        const moonMaterial = new THREE.MeshPhongMaterial({
            map: new THREE.TextureLoader().load('https://threejs.org/examples/textures/planets/moon_1024.jpg'),
            bumpMap: new THREE.TextureLoader().load('https://threejs.org/examples/textures/planets/moon_1024.jpg'),
            bumpScale: 0.05
        });
        const moon = new THREE.Mesh(moonGeometry, moonMaterial);
        moon.position.set(50, 0, 0);
        scene.add(moon);

        // 创建嫦娥六号模型（按照你提供的设计）
        const changE6Group = new THREE.Group();
        
        // 1. 轨道器 (顶部小型白色长方体)
        const orbiterGeometry = new THREE.BoxGeometry(0.075, 0.03, 0.075);
        const orbiterMaterial = new THREE.MeshPhongMaterial({ 
            color: 0xffffff,
            emissive: 0x222222,
            specular: 0x999999,
            shininess: 30
        });
        const orbiter = new THREE.Mesh(orbiterGeometry, orbiterMaterial);
        orbiter.position.y = 0.095;
        changE6Group.add(orbiter);
        
        // 2. 返回器 (大型白色长方体)
        const returnerGeometry = new THREE.BoxGeometry(0.1, 0.05, 0.1);
        const returnerMaterial = new THREE.MeshPhongMaterial({ 
            color: 0xffffff,
            emissive: 0x222222,
            specular: 0x999999,
            shininess: 30
        });
        const returner = new THREE.Mesh(returnerGeometry, returnerMaterial);
        returner.position.y = 0.05;
        changE6Group.add(returner);
        
        // 返回器的太阳能板 (两侧蓝色面板)
        const solarPanelGeometry = new THREE.BoxGeometry(0.12, 0.06, 0.01);
        const solarPanelMaterial = new THREE.MeshPhongMaterial({ 
            color: 0x0e197f,
            emissive: 0x003366,
            specular: 0x6666ff,
            shininess: 50
        });
        
        const leftSolarPanel = new THREE.Mesh(solarPanelGeometry, solarPanelMaterial);
        leftSolarPanel.position.set(-0.12, 0.0625, 0);
        leftSolarPanel.rotation.x = Math.PI/2;
        changE6Group.add(leftSolarPanel);
        
        const rightSolarPanel = new THREE.Mesh(solarPanelGeometry, solarPanelMaterial);
        rightSolarPanel.position.set(0.12, 0.0625, 0);
        rightSolarPanel.rotation.x = Math.PI/2;
        changE6Group.add(rightSolarPanel);
        
        // 3. 着陆器 (金色圆柱)
        const landerGeometry = new THREE.CylinderGeometry(0.05, 0.058, 0.05, 16);
        const landerMaterial = new THREE.MeshPhongMaterial({ 
            color: 0xb18f3b,
            emissive: 0x996600,
            specular: 0xffdd55,
            shininess: 40
        });
        const lander = new THREE.Mesh(landerGeometry, landerMaterial);
        lander.position.y = -0.005;
        changE6Group.add(lander);
        
        // 4. 上升器 (白色圆台)
        const ascenderGeometry = new THREE.CylinderGeometry(0.058, 0.058, 0.05, 16);
        const ascenderMaterial = new THREE.MeshPhongMaterial({ 
            color: 0x0e197f,
            emissive: 0x222222,
            specular: 0x999999,
            shininess: 30
        });
        const ascender = new THREE.Mesh(ascenderGeometry, ascenderMaterial);
        ascender.position.y = -0.06;
        changE6Group.add(ascender);

        // 5. 二级火箭 (白色圆柱，直径与上升器下底面相同)
        const rocketGeometry = new THREE.CylinderGeometry(0.07, 0.07, 0.12, 16); // 直径0.15(半径0.075)
        const rocketMaterial = new THREE.MeshPhongMaterial({ 
            color: 0xffffff,
            emissive: 0x222222,
            specular: 0x999999,
            shininess: 30
        });
        const rocket = new THREE.Mesh(rocketGeometry, rocketMaterial);
        rocket.position.y = -0.15; // 调整位置
        changE6Group.add(rocket);


        // 缩放嫦娥六号模型使其在场景中可见
        changE6Group.scale.set(10, 10, 10);
        scene.add(changE6Group);

        // 创建贝塞尔曲线飞行轨迹
        const curve = new THREE.CubicBezierCurve3(
            new THREE.Vector3(-50 + orbitRadius, 0, 0),
            new THREE.Vector3(-15, 25, 20),
            new THREE.Vector3(15, -20, -20),
            new THREE.Vector3(50, 0, 0)
        );

        // 创建白色虚线轨迹
        const points = curve.getPoints(150);
        const geometry = new THREE.BufferGeometry().setFromPoints(points);
        
        const material = new THREE.LineDashedMaterial({
            color: 0xffffff,
            dashSize: 1.0,
            gapSize: 0.5,
            linewidth: 1
        });
        
        const curveObject = new THREE.Line(geometry, material);
        curveObject.computeLineDistances();
        scene.add(curveObject);

        // 动画飞行路径
        let progress = 0;
        const speed = 0.001;
        const resetThreshold = 0.5;

        // 窗口大小调整
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        function resetFlight() {
            progress = 0;
            const point = curve.getPoint(progress);
            changE6Group.position.copy(point);
            
            const nextPoint = curve.getPoint(0.01);
            changE6Group.lookAt(nextPoint);
            changE6Group.rotateX(Math.PI / 2);
        }

        // 动画循环
        function animate() {
            requestAnimationFrame(animate);
            
            earth.rotation.y += 0.001;
            
            if (progress < 1) {
                progress += speed;
                const point = curve.getPoint(progress);
                changE6Group.position.copy(point);
                
                if (progress > 0.01 && progress < 0.99) {
                    const nextPoint = curve.getPoint(progress + 0.01);
                    changE6Group.lookAt(nextPoint);
                    changE6Group.rotateX(Math.PI / 2);
                }
                
                if (progress >= resetThreshold) {
                    resetFlight();
                }
            }
            
            renderer.render(scene, camera);
        }

        resetFlight();
        animate();
    </script>
</body>
</html>